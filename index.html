<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Three.js ä¸‰äººç§°ã‚«ãƒ¡ãƒ©ï¼†èµ¤ã„çƒï¼ˆGLBãƒ«ãƒ¼ãƒ èª­ã¿è¾¼ã¿ï¼‰</title>
  <style>
    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      overflow: hidden;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
    }

    #ui {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 10px 12px;
      background: rgba(0, 0, 0, .45);
      color: #fff;
      font-size: 13px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, .25);
    }

    #ui kbd {
      background: rgba(255, 255, 255, .14);
      padding: 1px 6px;
      border-radius: 6px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
    }

    #fps {
      position: fixed;
      right: 12px;
      top: 12px;
      color: #9ad6ff;
      font: 12px/1 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      opacity: .85;
    }

    #status {
      position: fixed;
      left: 12px;
      bottom: 12px;
      color: #fff;
      background: rgba(0, 0, 0, .55);
      padding: 8px 10px;
      border-radius: 8px;
      font: 12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      max-width: 60ch;
    }
  </style>
</head>

<body>
  <div id="ui">
    <div>ğŸ® <strong>æ“ä½œ</strong> â€” <kbd>WASD</kbd> ç§»å‹• / <kbd>Shift</kbd> ãƒ€ãƒƒã‚·ãƒ¥ / <kbd>Space</kbd> ã‚¸ãƒ£ãƒ³ãƒ— /
      ãƒã‚¦ã‚¹<strong>ãƒ‰ãƒ©ãƒƒã‚°</strong>ã§ã‚«ãƒ¡ãƒ©å›è»¢ / <kbd>ãƒ›ã‚¤ãƒ¼ãƒ«</kbd>ã§è·é›¢ / <kbd>R</kbd> ãƒªã‚¹ãƒãƒ¼ãƒ³ / <kbd>H</kbd> ãƒ˜ãƒ«ãƒ‘ãƒ¼åˆ‡æ›¿</div>
  </div>
  <div id="fps"></div>
  <div id="status">waiting for <code>room_sample.glb</code>â€¦</div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.160.0';
    import { GLTFLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';
    import { DRACOLoader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/DRACOLoader.js';
    import { KTX2Loader } from 'https://esm.sh/three@0.160.0/examples/jsm/loaders/KTX2Loader.js';

    // --- Renderer ---
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // --- Scene & Camera ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdfe7f1);
    // ãƒ‡ãƒãƒƒã‚°ã—ã‚„ã™ã„ã‚ˆã†ä¸€æ—¦ãƒ•ã‚©ã‚°OFFï¼ˆå¿…è¦ãªã‚‰å¾Œã§æœ‰åŠ¹åŒ–ï¼‰
    scene.fog = null;

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 3, 8);

    // ä¸‰äººç§°ã‚«ãƒ¡ãƒ©ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    let camYaw = 0.0;              // Yå‘¨ã‚Šè§’ï¼ˆå·¦å³ï¼‰
    let camPitch = Math.PI * 0.38; // ä¸Šä¸‹ï¼ˆ0ã€œÏ€ï¼‰
    let camDist = 7.0;             // è·é›¢
    let camMinDist = 2.2, camMaxDist = 30.0;

    // --- Lights ---
    const hemi = new THREE.HemisphereLight(0xbfdfff, 0x526b52, 0.7);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.9);
    dir.position.set(10, 16, 10);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    dir.shadow.camera.near = 0.5;
    dir.shadow.camera.far = 80;
    scene.add(dir);
    scene.add(new THREE.AmbientLight(0xffffff, 0.15)); // æœ€ä½é™ã®ç’°å¢ƒå…‰

    // --- World (GLB room) ---
    const worldRoot = new THREE.Group();
    scene.add(worldRoot);

    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯åœ°é¢ï¼ˆGLBå¤±æ•—æ™‚ã®è¦‹ã‚„ã™ã•å‘ä¸Šï¼‰
    const fallbackGround = new THREE.Mesh(
      new THREE.PlaneGeometry(120, 120),
      new THREE.MeshStandardMaterial({ color: 0x93c47d, roughness: 1 })
    );
    fallbackGround.rotation.x = -Math.PI / 2;
    fallbackGround.receiveShadow = true;
    scene.add(fallbackGround);

    const staticMeshes = []; // å½“ãŸã‚Šåˆ¤å®šãƒ»åœ°é¢åˆ¤å®šå¯¾è±¡
    let worldBBox = null; // ãƒ«ãƒ¼ãƒ å…¨ä½“ã®BBox
    let worldLoaded = false; // GLBèª­è¾¼å®Œäº†ãƒ•ãƒ©ã‚°
    let bboxHelper = null;
    const statusEl = document.getElementById('status');

    // GLTFãƒ­ãƒ¼ãƒ€ãƒ¼ + Draco/KTX2 å¯¾å¿œ
    const draco = new DRACOLoader();
    draco.setDecoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/draco/');
    const ktx2 = new KTX2Loader();
    ktx2.setTranscoderPath('https://unpkg.com/three@0.160.0/examples/jsm/libs/basis/').detectSupport(renderer);

    const loader = new GLTFLoader();
    loader.setDRACOLoader(draco);
    loader.setKTX2Loader(ktx2);

    const ROOM_URL = new URL('./room_sample.glb', import.meta.url).href;

    loader.load(ROOM_URL, (gltf) => {
      const room = gltf.scene;
      room.traverse((o) => {
        if (o.isMesh) {
          o.castShadow = true; o.receiveShadow = true;
          staticMeshes.push(o);
        }
      });
      worldRoot.add(room);
      worldLoaded = true;
      fallbackGround.visible = false;
      statusEl.textContent = 'room_sample.glb: loaded';

      // --- BBox ã‹ã‚‰ã‚¹ã‚±ãƒ¼ãƒ«ãƒ»ä¸­å¿ƒãƒ»åºŠã‚’æ¨å®š
      worldBBox = new THREE.Box3().setFromObject(room);
      const size = worldBBox.getSize(new THREE.Vector3());
      const center = worldBBox.getCenter(new THREE.Vector3());

      // ã‚«ãƒ¡ãƒ© near/far ã‚’ã‚·ãƒ¼ãƒ³è¦æ¨¡ã«åˆã‚ã›ã‚‹
      const diag = size.length();
      camera.near = Math.max(0.01, diag * 1e-4);
      camera.far = Math.max(500, diag * 2.0);
      camera.updateProjectionMatrix();

      // ãƒ¬ã‚¤é–‹å§‹é«˜ã•
      rayTopY = worldBBox.max.y + Math.max(5, size.y * 0.5);

      // ã‚¢ãƒã‚¿ãƒ¼ã®ã‚µã‚¤ã‚ºèª¿æ•´
      const targetR = THREE.MathUtils.clamp(diag * 0.02, 0.25, 1.5);
      const k = targetR / SPHERE_R;
      avatar.scale.setScalar(k);
      SPHERE_R = targetR;

      // ã‚¹ãƒãƒ¼ãƒ³
      const gy = groundHeightAt(center.x, center.z);
      const spawnY = Number.isFinite(gy) ? gy + SPHERE_R : center.y + SPHERE_R;
      avatar.position.set(center.x, spawnY, center.z);

      // ã‚«ãƒ¡ãƒ©è·é›¢
      camMinDist = Math.max(1.5, SPHERE_R * 3);
      camMaxDist = Math.max(20.0, diag * 0.6);
      camDist = Math.min(Math.max(camDist, camMinDist + 0.5), camMaxDist * 0.6);

      // BBoxå¯è¦–åŒ–ï¼ˆHã§åˆ‡æ›¿ï¼‰
      bboxHelper = new THREE.Box3Helper(worldBBox, 0x00ff88);
      scene.add(bboxHelper);

    }, (e) => {
      if (e && e.total) {
        const p = (e.loaded / e.total * 100).toFixed(0);
        statusEl.textContent = `loading room_sample.glbâ€¦ ${p}%`;
      } else {
        statusEl.textContent = 'loading room_sample.glbâ€¦';
      }
    }, (err) => {
      console.error('GLB load error:', err);
      statusEl.textContent = `GLB load error: ${err?.message || err}`;
    });

    // ç°¡æ˜“ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ï¼ˆHTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ï¼‰
    fetch(ROOM_URL, { method: 'HEAD' }).then(r => {
      if (!r.ok) statusEl.textContent = `HTTP ${r.status} for room_sample.glb`;
    }).catch(e => {
      statusEl.textContent = `Fetch error for room_sample.glb: ${e}`;
    });

    // ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ï¼ˆã‚«ãƒ©ãƒ•ãƒ«ãªç®±ã‚’ã„ãã¤ã‹ï¼‰
    const palette = [0xff7675, 0x74b9ff, 0x55efc4, 0xfdcb6e, 0xa29bfe, 0xffb4a2];
    const boxGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
    for (let i = 0; i < 18; i++) {
      const mat = new THREE.MeshStandardMaterial({ color: palette[i % palette.length], roughness: 0.8 });
      const b = new THREE.Mesh(boxGeo, mat);
      b.castShadow = true; b.receiveShadow = true;
      const r = 30 + Math.random() * 90; const t = Math.random() * Math.PI * 2;
      b.position.set(Math.cos(t) * r, 0.6, Math.sin(t) * r);
      scene.add(b);
    }

    // --- Avatar: èµ¤ã„çƒä½“ ---
    let SPHERE_R = 0.5;
    const avatar = new THREE.Mesh(
      new THREE.SphereGeometry(SPHERE_R, 32, 16),
      new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5, metalness: 0.0, emissive: 0x220000, emissiveIntensity: 0.25 })
    );
    avatar.castShadow = true;
    avatar.position.set(0, SPHERE_R, 0);
    scene.add(avatar);

    // ç›®å°ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ“ã‚³ãƒ³ï¼†ãƒ©ã‚¤ãƒˆï¼†åº§æ¨™è»¸
    const avatarLamp = new THREE.PointLight(0xff4444, 1.2, 10);
    avatar.add(avatarLamp);
    const avatarAxes = new THREE.AxesHelper(1.2); avatar.add(avatarAxes);
    const beaconMat = new THREE.SpriteMaterial({ color: 0xff3344, transparent: true, opacity: 0.85, depthTest: false });
    const beacon = new THREE.Sprite(beaconMat); beacon.scale.set(0.8, 0.8, 0.8); beacon.position.y = SPHERE_R * 1.8; avatar.add(beacon);
    let helpersVisible = true;

    // --- Input state ---
    const keys = Object.create(null);
    addEventListener('keydown', (e) => {
      if (!e.repeat) {
        if (e.code === 'KeyH') { helpersVisible = !helpersVisible; toggleHelpers(); }
        if (e.code === 'KeyR') { respawnAtCenter(); }
      }
      keys[e.code] = true;
    });
    addEventListener('keyup', (e) => keys[e.code] = false);

    // ãƒã‚¦ã‚¹ã§ã‚«ãƒ¡ãƒ©å›è»¢
    let dragging = false; let lastX = 0, lastY = 0;
    addEventListener('mousedown', (e) => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    addEventListener('mouseup', () => dragging = false);
    addEventListener('mouseleave', () => dragging = false);
    addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX; const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      camYaw -= dx * 0.0035;           // å·¦å³å›è»¢
      camPitch -= dy * 0.0030;           // ä¸Šä¸‹å›è»¢
      camPitch = Math.max(0.05, Math.min(Math.PI * 0.95, camPitch));
    });
    addEventListener('wheel', (e) => {
      camDist = Math.min(camMaxDist, Math.max(camMinDist, camDist + e.deltaY * 0.002));
    }, { passive: true });

    // --- Movement params ---
    const WALK = 3.0;     // m/s
    const RUN = 5.6;     // m/s
    const GRAVITY = 18.0; // ç°¡æ˜“é‡åŠ›
    const JUMP_V = 8.0;   // ã‚¸ãƒ£ãƒ³ãƒ—åˆé€Ÿ
    let vY = 0;           // å‚ç›´é€Ÿåº¦

    const up = new THREE.Vector3(0, 1, 0);
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();
    const target = new THREE.Vector3();
    const camOffset = new THREE.Vector3();
    const desiredCamPos = new THREE.Vector3();
    let firstFocus = true;

    function toggleHelpers() {
      if (bboxHelper) bboxHelper.visible = helpersVisible;
      avatarAxes.visible = helpersVisible;
    }

    function respawnAtCenter() {
      if (worldBBox) {
        const c = worldBBox.getCenter(new THREE.Vector3());
        const gy = groundHeightAt(c.x, c.z);
        const y = Number.isFinite(gy) ? gy + SPHERE_R : c.y + SPHERE_R;
        avatar.position.set(c.x, y, c.z);
        firstFocus = true; // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã‚«ãƒ¡ãƒ©å³è¿½å¾“
      } else {
        avatar.position.set(0, SPHERE_R, 0);
        firstFocus = true;
      }
    }

    // --- Raycaster for ground & wall ---
    const ray = new THREE.Raycaster();
    ray.far = 100;
    let rayTopY = 50; // GLBèª­è¾¼å¾Œã«æ›´æ–°
    function groundHeightAt(x, z) {
      if (staticMeshes.length === 0) return 0; // GLBæœªèª­è¾¼æ™‚ã®æš«å®š
      ray.set(new THREE.Vector3(x, rayTopY, z), new THREE.Vector3(0, -1, 0));
      const hits = ray.intersectObjects(staticMeshes, true);
      return hits.length ? hits[0].point.y : 0;
    }

    function willHitWall(from, dir, dist) {
      if (staticMeshes.length === 0) return dist; // æœªèª­è¾¼æ™‚ã¯ç„¡è¦–
      const eps = 1e-2;
      ray.set(from, dir.clone().normalize());
      const hits = ray.intersectObjects(staticMeshes, true);
      if (!hits.length) return dist;
      const d = hits[0].distance;
      if (d < dist + SPHERE_R) return Math.max(0, d - SPHERE_R - eps);
      return dist;
    }

    // FPS è¡¨ç¤ºï¼ˆç°¡æ˜“ï¼‰
    const fpsEl = document.getElementById('fps');
    let fpsAcc = 0, fpsFrames = 0, fpsTimer = 0;

    const clock = new THREE.Clock();
    function animate() {
      const dt = Math.min(clock.getDelta(), 0.05);

      // 1) ã‚«ãƒ¡ãƒ©æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆæ°´å¹³é¢ï¼‰
      forward.set(Math.sin(camYaw), 0, Math.cos(camYaw));
      right.set(Math.cos(camYaw), 0, -Math.sin(camYaw));

      // 2) å…¥åŠ›åˆæˆï¼ˆWASD ã¯ã‚«ãƒ¡ãƒ©åŸºæº–ï¼‰
      const move = new THREE.Vector3();
      if (keys['KeyW']) move.add(forward);
      if (keys['KeyS']) move.sub(forward);
      if (keys['KeyA']) move.sub(right);
      if (keys['KeyD']) move.add(right);

      const speed = (keys['ShiftLeft'] || keys['ShiftRight']) ? RUN : WALK;
      if (move.lengthSq() > 0) {
        move.normalize();
        // å£å½“ãŸã‚Šã‚’ç°¡æ˜“åˆ¤å®šï¼ˆå‰æ–¹ãƒ¬ã‚¤ï¼‰
        const step = speed * dt;
        const allowed = willHitWall(new THREE.Vector3(avatar.position.x, avatar.position.y, avatar.position.z), move, step);
        avatar.position.addScaledVector(move, allowed);
      }

      // 3) ã‚¸ãƒ£ãƒ³ãƒ—ãƒ»é‡åŠ› + åœ°é¢ã‚¹ãƒŠãƒƒãƒ—ï¼ˆGLBåºŠï¼‰
      const gy = groundHeightAt(avatar.position.x, avatar.position.z);
      const onGround = Math.abs(avatar.position.y - (gy + SPHERE_R)) < 1e-3;
      if (keys['Space'] && onGround) vY = JUMP_V;
      vY -= GRAVITY * dt;
      avatar.position.y += vY * dt;
      if (avatar.position.y < gy + SPHERE_R) { avatar.position.y = gy + SPHERE_R; vY = 0; }

      // 4) ä¸‰äººç§°ã‚«ãƒ¡ãƒ©ï¼ˆè‚©è¶Šã—é¢¨ï¼‰ & éšœå®³ç‰©ã§æ‰‹å‰ã«å¯„ã›ã‚‹
      target.set(avatar.position.x, avatar.position.y + SPHERE_R * 0.8, avatar.position.z);
      camOffset.setFromSpherical(new THREE.Spherical(camDist, camPitch, camYaw));
      desiredCamPos.copy(target).add(camOffset);

      // ã‚«ãƒ¡ãƒ©é®è”½å›é¿
      if (staticMeshes.length) {
        const dirToCam = desiredCamPos.clone().sub(target).normalize();
        ray.set(target, dirToCam);
        const dist = desiredCamPos.distanceTo(target);
        const hits = ray.intersectObjects(staticMeshes, true);
        if (hits.length && hits[0].distance < dist) {
          desiredCamPos.copy(target).addScaledVector(dirToCam, Math.max(0.3, hits[0].distance - 0.2));
        }
      }

      if (firstFocus) { camera.position.copy(desiredCamPos); firstFocus = false; }
      else { camera.position.lerp(desiredCamPos, 0.18); }
      camera.lookAt(target);

      // 5) ãƒ¬ãƒ³ãƒ€ï¼†FPS
      renderer.render(scene, camera);

      fpsAcc += 1 / dt; fpsFrames++; fpsTimer += dt;
      if (fpsTimer > 0.5) { fpsEl.textContent = (fpsAcc / fpsFrames).toFixed(0) + ' FPS'; fpsAcc = 0; fpsFrames = 0; fpsTimer = 0; }

      requestAnimationFrame(animate);
    }
    animate();
    animate();

    // --- Resize ---
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    console.log('%cTIP', 'background:#34d399;color:#111;padding:2px 6px;border-radius:6px', 'ãƒ­ãƒ¼ã‚«ãƒ«HTTPã‚µãƒ¼ãƒãƒ¼ã§é–‹ã„ã¦ãã ã•ã„ã€‚ä¾‹: `python3 -m http.server`');
  </script>
</body>

</html>